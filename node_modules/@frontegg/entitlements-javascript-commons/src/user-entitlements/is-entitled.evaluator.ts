import {
  EntitlementResult,
  NotEntitledJustification,
  NO_EXPIRATION_TIME,
  UserEntitlementsContext,
  Attributes,
} from './types';

import { evaluateFeatureFlag } from '../feature-flags';
import { prepareAttributes } from './attributes.utils';
import { TreatmentEnum } from '../rules';
import { checkPermission } from './permissions.utils';
export function evaluateIsEntitledToFeature(
  featureKey: string,
  userEntitlementsContext: UserEntitlementsContext,
  attributes: Attributes = {},
): EntitlementResult {
  const feature = userEntitlementsContext.features[featureKey];
  let hasExpired = false;
  if (feature && feature.expireTime !== null) {
    hasExpired = feature.expireTime !== NO_EXPIRATION_TIME && feature.expireTime < Date.now();

    if (!hasExpired) {
      return { isEntitled: true };
    }
  }

  if (feature && feature.featureFlag) {
    const preparedAttributes = prepareAttributes(attributes);
    const { treatment } = evaluateFeatureFlag(feature.featureFlag, preparedAttributes);
    if (treatment === TreatmentEnum.True) {
      return { isEntitled: true };
    }
  }

  return {
    isEntitled: false,
    justification: hasExpired ? NotEntitledJustification.BUNDLE_EXPIRED : NotEntitledJustification.MISSING_FEATURE,
  };
}

export function evaluateIsEntitledToPermissions(
  permissionKey: string,
  userEntitlementsContext: UserEntitlementsContext,
  attributes?: Attributes,
): EntitlementResult {
  const hasPermission = checkPermission(userEntitlementsContext.permissions, permissionKey);
  if (!hasPermission) {
    return { isEntitled: false, justification: NotEntitledJustification.MISSING_PERMISSION };
  }

  const linkedFeatures = getLinkedFeatures(permissionKey, userEntitlementsContext);

  if (!linkedFeatures.length) {
    return { isEntitled: true };
  }

  let hasExpired = false;

  for (const featureKey of linkedFeatures) {
    const { isEntitled, justification } = evaluateIsEntitledToFeature(featureKey, userEntitlementsContext, attributes);

    if (isEntitled) {
      return { isEntitled: true };
    }

    if (justification === NotEntitledJustification.BUNDLE_EXPIRED) {
      hasExpired = true;
    }
  }

  return {
    isEntitled: false,
    justification: hasExpired ? NotEntitledJustification.BUNDLE_EXPIRED : NotEntitledJustification.MISSING_FEATURE,
  };
}

function getLinkedFeatures(permissionKey: string, userEntitlementsContext: UserEntitlementsContext): string[] {
  return Object.keys(userEntitlementsContext.features).filter((featureKey) =>
    userEntitlementsContext.features[featureKey].linkedPermissions.includes(permissionKey),
  );
}
