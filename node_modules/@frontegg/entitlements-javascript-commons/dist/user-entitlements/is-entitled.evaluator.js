"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateIsEntitledToPermissions = exports.evaluateIsEntitledToFeature = void 0;
const types_1 = require("./types");
const feature_flags_1 = require("../feature-flags");
const attributes_utils_1 = require("./attributes.utils");
const rules_1 = require("../rules");
const permissions_utils_1 = require("./permissions.utils");
function evaluateIsEntitledToFeature(featureKey, userEntitlementsContext, attributes = {}) {
    const feature = userEntitlementsContext.features[featureKey];
    let hasExpired = false;
    if (feature && feature.expireTime !== null) {
        hasExpired = feature.expireTime !== types_1.NO_EXPIRATION_TIME && feature.expireTime < Date.now();
        if (!hasExpired) {
            return { isEntitled: true };
        }
    }
    if (feature && feature.featureFlag) {
        const preparedAttributes = (0, attributes_utils_1.prepareAttributes)(attributes);
        const { treatment } = (0, feature_flags_1.evaluateFeatureFlag)(feature.featureFlag, preparedAttributes);
        if (treatment === rules_1.TreatmentEnum.True) {
            return { isEntitled: true };
        }
    }
    return {
        isEntitled: false,
        justification: hasExpired ? types_1.NotEntitledJustification.BUNDLE_EXPIRED : types_1.NotEntitledJustification.MISSING_FEATURE,
    };
}
exports.evaluateIsEntitledToFeature = evaluateIsEntitledToFeature;
function evaluateIsEntitledToPermissions(permissionKey, userEntitlementsContext, attributes) {
    const hasPermission = (0, permissions_utils_1.checkPermission)(userEntitlementsContext.permissions, permissionKey);
    if (!hasPermission) {
        return { isEntitled: false, justification: types_1.NotEntitledJustification.MISSING_PERMISSION };
    }
    const linkedFeatures = getLinkedFeatures(permissionKey, userEntitlementsContext);
    if (!linkedFeatures.length) {
        return { isEntitled: true };
    }
    let hasExpired = false;
    for (const featureKey of linkedFeatures) {
        const { isEntitled, justification } = evaluateIsEntitledToFeature(featureKey, userEntitlementsContext, attributes);
        if (isEntitled) {
            return { isEntitled: true };
        }
        if (justification === types_1.NotEntitledJustification.BUNDLE_EXPIRED) {
            hasExpired = true;
        }
    }
    return {
        isEntitled: false,
        justification: hasExpired ? types_1.NotEntitledJustification.BUNDLE_EXPIRED : types_1.NotEntitledJustification.MISSING_FEATURE,
    };
}
exports.evaluateIsEntitledToPermissions = evaluateIsEntitledToPermissions;
function getLinkedFeatures(permissionKey, userEntitlementsContext) {
    return Object.keys(userEntitlementsContext.features).filter((featureKey) => userEntitlementsContext.features[featureKey].linkedPermissions.includes(permissionKey));
}
//# sourceMappingURL=is-entitled.evaluator.js.map